<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="manifest" href="manifest.json">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Meta tags for PWA -->
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Photos">
    <link rel="apple-touch-icon" href="/control/icons/image512.png" onerror="this.onerror=null;this.src='https://placehold.co/180x180/000000/FFFFFF?text=Icon';">
    <link rel="icon" href="/control/icons/image512.png" onerror="this.onerror=null;this.src='https://placehold.co/32x32/000000/FFFFFF?text=Icon';">

    <title>Atma by Heri Sanjaya</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=Lora:ital,wght@0,400;0,600&display=swap" rel="stylesheet">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- QR Code Generator Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: "Inter", sans-serif;
            color: #000;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            margin: 0;
        }
        #app-wrapper {
            display: none;
        }
        #app-wrapper.unlocked {
            display: block;
        }
        #app-container {
            width: 100vw;
            height: 100vh;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #display-area {
            position: relative;
            width: 100vw;
            height: 100vw;
            max-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        #slide-container {
            height: 100%;
            display: flex;
            gap: 20px;
        }
        .slide {
            height: 100%;
            width: 100vw;
            flex-shrink: 0;
            box-sizing: border-box;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .slide-content {
            width: 100%;
            height: 100%;
            background-color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 25px;
            box-sizing: border-box;
        }
        .slide-content img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #history-overlay {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #fff;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 1rem;
            text-align: left;
            display: none;
            z-index: 20;
        }
        #history-overlay.show {
            display: block;
        }
        .font-playfair { font-family: 'Playfair Display', serif; }
        .font-lora { font-family: 'Lora', serif; }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body id="touchArea" class="bg-black">

    <!-- License Modal -->
    <div id="license-modal" class="fixed inset-0 bg-black bg-opacity-90 flex justify-center items-center z-50 p-4" style="display: none;">
        <div class="font-lora bg-[#fdfaf3] rounded-sm p-6 w-full max-w-sm text-[#1a1a1a] border-2 border-black shadow-2xl text-center">
            <h2 class="font-playfair text-2xl mb-4 border-b-2 border-gray-400 pb-2 uppercase">License Activation</h2>
            <p class="mb-6">Please enter your license key to unlock the app.</p>
            <input type="text" id="license-key-input" placeholder="ABC-123-XYZ" class="w-full p-3 text-center border-2 border-black rounded-sm mb-4 bg-white text-lg tracking-widest">
            <button id="verify-license-btn" class="font-playfair w-full bg-black hover:bg-gray-800 text-[#fdfaf3] p-3 rounded-sm uppercase tracking-wider transition-colors duration-300 flex items-center justify-center">
                <span>Activate</span>
            </button>
            <p id="license-error" class="text-red-600 mt-4 text-sm h-5"></p>
        </div>
    </div>

    <!-- App Wrapper -->
    <div id="app-wrapper">
        <!-- One-time Settings Notification -->
        <div id="settings-toast" class="hidden fixed top-4 left-1/2 -translate-x-1/2 w-11/12 max-w-sm bg-[#fdfaf3] text-[#1a1a1a] p-3 rounded-sm shadow-lg z-30 flex items-center justify-between font-lora border-2 border-black">
            <p>Tip: Tap the top-right corner for settings.</p>
            <button id="close-toast-btn" class="text-2xl font-bold leading-none pl-4">&times;</button>
        </div>

        <!-- Main container -->
        <div id="app-container">
            <div id="display-area">
                <div id="slide-container"></div>
            </div>
        </div>

        <!-- History overlay -->
        <div id="history-overlay"></div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-75 flex justify-center items-center hidden z-50 p-4">
            <div class="font-lora bg-[#fdfaf3] rounded-sm p-6 w-11/12 max-w-sm text-[#1a1a1a] border-2 border-black shadow-2xl">
                <h2 id="settings-title" class="font-playfair text-2xl mb-4 border-b-2 border-gray-400 pb-2 uppercase">Settings</h2>
                
                <!-- Custom ID Input (for Printed QR mode) -->
                <div id="custom-id-section" class="my-6">
                    <label for="custom-id-input" class="font-playfair block mb-2 font-bold">Custom ID:</label>
                    <p class="text-sm mb-2">Set a 6-digit ID to link with your printed QR code.</p>
                    <input type="number" id="custom-id-input" placeholder="6-digit number" class="w-full p-3 text-center border-2 border-black rounded-sm bg-white text-lg tracking-widest transition-colors duration-200" oninput="this.value=this.value.slice(0,6)">
                    
                    <button id="change-id-btn" class="hidden font-playfair w-full mt-2 p-2 rounded-sm border-2 border-black uppercase tracking-wider hover:bg-gray-200">Change ID</button>
                    
                    <p id="custom-id-error" class="text-red-600 mt-2 text-sm h-5"></p>
                    
                    <div id="id-actions-container" class="flex space-x-2 mt-4">
                        <button id="download-qr-btn" class="font-playfair w-full block bg-black hover:bg-gray-800 text-[#fdfaf3] p-2 rounded-sm text-center uppercase tracking-wider transition-colors duration-300">Download QR</button>
                        <button id="delete-id-btn" class="font-playfair w-full block bg-red-700 hover:bg-red-800 text-[#fdfaf3] p-2 rounded-sm text-center uppercase tracking-wider transition-colors duration-300">Delete ID</button>
                    </div>
                </div>

                <!-- Language Selection -->
                <div class="my-6">
                    <label id="language-label" class="font-playfair block mb-2 font-bold">Language:</label>
                    <div class="flex space-x-4">
                        <button id="lang-id" class="font-playfair flex-1 p-2 rounded-sm border-2 uppercase tracking-wider">Indonesia</button>
                        <button id="lang-eng" class="font-playfair flex-1 p-2 rounded-sm border-2 uppercase tracking-wider">English</button>
                    </div>
                </div>
                
                <a href="user-guide.html" id="read-instructions-btn" class="font-playfair w-full block bg-black hover:bg-gray-800 text-[#fdfaf3] p-2 rounded-sm text-center uppercase tracking-wider transition-colors duration-300 mt-6">Read Instructions</a>
                
                <button id="save-settings-btn" class="font-playfair w-full bg-black hover:bg-gray-800 text-[#fdfaf3] p-2 rounded-sm uppercase tracking-wider transition-colors duration-300 mt-2">Save & Close</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/9.6.10/firebase-firestore.js";

        // --- DOM ELEMENT REFERENCES ---
        const licenseModal = document.getElementById('license-modal');
        const licenseKeyInput = document.getElementById('license-key-input');
        const verifyLicenseBtn = document.getElementById('verify-license-btn');
        const licenseError = document.getElementById('license-error');
        const appWrapper = document.getElementById('app-wrapper');
        const settingsToast = document.getElementById('settings-toast');
        const closeToastBtn = document.getElementById('close-toast-btn');
        const displayArea = document.getElementById('display-area');
        const slideContainer = document.getElementById('slide-container');
        const touchArea = document.getElementById('touchArea');
        const historyOverlayElement = document.getElementById('history-overlay');
        const settingsModal = document.getElementById('settings-modal');
        const settingsTitle = document.getElementById('settings-title');
        const languageLabel = document.getElementById('language-label');
        const langIdButton = document.getElementById('lang-id');
        const langEngButton = document.getElementById('lang-eng');
        const readInstructionsButton = document.getElementById('read-instructions-btn');
        // Settings elements
        const customIdSection = document.getElementById('custom-id-section');
        const customIdInput = document.getElementById('custom-id-input');
        const customIdError = document.getElementById('custom-id-error');
        const changeIdBtn = document.getElementById('change-id-btn');
        const idActionsContainer = document.getElementById('id-actions-container');
        const downloadQrBtn = document.getElementById('download-qr-btn');
        const deleteIdBtn = document.getElementById('delete-id-btn');
        const saveSettingsBtn = document.getElementById('save-settings-btn');


        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyCFDxFe2PnyxaLRb7VctQSHhQh7ZKoSDaU",
            authDomain: "atmamagicbyheri.firebaseapp.com",
            projectId: "atmamagicbyheri",
            storageBucket: "atmamagicbyheri.appspot.com",
            messagingSenderId: "672288947327",
            appId: "1:672288947327:web:4ee5d222045bfaf6ed934a"
        };

        // --- Initialize Firebase ---
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- LANGUAGE & TRANSLATIONS ---
        const translations = {
            id: { victimName: 'Nama Korban:', crimeScene: 'Lokasi Kejadian:', weapon: 'Alat yang Dipakai:', noHistory: 'Tidak ada riwayat gerakan.', settingsTitle: 'Pengaturan', languageLabel: 'Bahasa:', closeButton: 'Tutup', readInstructions: 'Baca Instruksi', langId: 'Indonesia', langEng: 'English', mustSetId: 'ID kustom harus diisi sebelum keluar.' },
            eng: { victimName: "Victim's Name:", crimeScene: 'Crime Scene:', weapon: 'Weapon Used:', noHistory: 'No gesture history.', settingsTitle: 'Settings', languageLabel: 'Language:', closeButton: 'Close', readInstructions: 'Read Instructions', langId: 'Indonesia', langEng: 'English', mustSetId: 'Custom ID must be set before exiting.' }
        };

        // --- APP CONTENT ---
        const displayContent = {
            id: [ { title: translations.id.victimName, items: ['Eleanor', 'Abigail', 'Lillian', 'Margaret', 'Beatrice'] }, { title: translations.id.crimeScene, items: ['Kamar lantai dua', 'Loteng', 'Gudang belakang', 'Ruang bawah tanah', 'Lorong dekat dapur'] }, { title: translations.id.weapon, items: ['Pisau', 'Palu', 'Gunting', 'Linggis', 'Batang besi'] } ],
            eng: [ { title: translations.eng.victimName, items: ['Eleanor', 'Abigail', 'Lillian', 'Margaret', 'Beatrice'] }, { title: translations.eng.crimeScene, items: ['Second floor room', 'Attic', 'Back warehouse', 'Basement', 'Hallway near kitchen'] }, { title: translations.eng.weapon, items: ['Knife', 'Hammer', 'Scissors', 'Crowbar', 'Iron rod'] } ]
        };
        const gestureTexts = [
            { 'Up': 'Eleanor', 'Right': 'Abigail', 'Down': 'Lillian', 'Left': 'Margaret', 'Tap': 'Beatrice' },
            { 'Up': 'kamar lantai dua', 'Right': 'loteng', 'Down': 'gudang belakang', 'Left': 'ruang bawah tanah', 'Tap': 'lorong dekat dapur' },
            { 'Up': 'pisau', 'Right': 'palu', 'Down': 'gunting', 'Left': 'linggis', 'Tap': 'batang besi' }
        ];

        // --- STATE & CONSTANTS ---
        let startX = 0, startY = 0, gestureCount = 0, currentSlideIndex = 0;
        const gestureSequence = [], gestureTextHistory = [];
        let isSessionActive = true, tapCount = 0, lastTapTime = 0, tapHoldTimeout = null;
        let startArea = null, isDragging = false, initialTranslate = 0;
        let isImageRevealed = false; // Tracks if the secret image has been shown
        let deleteConfirmationTimeout = null;
        let oldIdToReplace = null;
        let initialSettings = {}; // For tracking changes in settings
        
        // App settings state
        const appMode = 'printed'; // Mode is now fixed to 'printed'
        let customId = '';
        let currentLanguage = 'eng';

        const SWIPE_THRESHOLD = 50, TAP_THRESHOLD = 10, DOUBLE_TAP_TIMEOUT = 300;
        const TAP_HOLD_DURATION = 500, TOTAL_SLIDES = 4, SLIDE_GAP = 20;
        const SETTINGS_CORNER_SIZE = 60;
        const gridToGesture = { 'a': 'A', 'b': 'B', 'c': 'C', 'd': 'D', 'e': 'E' };
        const gestureToCode = { 'A': 'Fl', 'B': 'uC', 'C': 'zW', 'D': 'Xy', 'E': 'Qr' };
        const gestureToTextKey = { 'A': 'Up', 'B': 'Right', 'C': 'Left', 'D': 'Down', 'E': 'Tap' };

        // --- LICENSE LOGIC (using Firestore) ---
        const showLicenseModal = () => { licenseModal.style.display = 'flex'; appWrapper.classList.remove('unlocked'); };
        const showSettingsToastIfNeeded = () => { if (!localStorage.getItem('atmaSettingsToastShown')) { settingsToast.classList.remove('hidden'); localStorage.setItem('atmaSettingsToastShown', 'true'); } };
        
        const unlockApp = () => {
            licenseModal.style.display = 'none';
            appWrapper.classList.add('unlocked');
            loadSettings(); // Load settings after unlock
            showSettingsToastIfNeeded();
        };

        const setButtonLoading = (isLoading) => {
            const buttonContent = verifyLicenseBtn.querySelector('span');
            const spinner = verifyLicenseBtn.querySelector('.spinner');
            if (isLoading) {
                buttonContent.style.display = 'none';
                if (!spinner) {
                    const newSpinner = document.createElement('div');
                    newSpinner.className = 'spinner';
                    verifyLicenseBtn.appendChild(newSpinner);
                }
            } else {
                buttonContent.style.display = 'inline';
                if (spinner) spinner.remove();
            }
        };

        const verifyLicense = async () => {
            const key = licenseKeyInput.value.trim().toUpperCase();
            if (!key) { licenseError.textContent = 'Please enter a license key.'; return; }
            setButtonLoading(true);
            licenseError.textContent = '';
            try {
                const availableLicenseRef = doc(db, 'availableLicenses', key);
                const licenseSnap = await getDoc(availableLicenseRef);
                if (licenseSnap.exists() && licenseSnap.data().status === 'available') {
                    const originalData = licenseSnap.data();
                    const activatedLicenseRef = doc(db, 'activatedLicenses', key);
                    await setDoc(activatedLicenseRef, { ...originalData, status: 'used', uid: auth.currentUser.uid, claimedAt: serverTimestamp() });
                    await deleteDoc(availableLicenseRef);
                    localStorage.setItem('atmaLicense', JSON.stringify({ key: key, lastValidated: new Date().getTime() }));
                    unlockApp();
                } else {
                    licenseError.textContent = 'Invalid or already used license key.';
                }
            } catch (error) {
                console.error("Error verifying license:", error);
                licenseError.textContent = 'Verification failed. Please try again.';
            } finally {
                setButtonLoading(false);
            }
        };
        
        const checkLicenseOnLoad = async () => {
            const licenseDataString = localStorage.getItem('atmaLicense');
            if (!licenseDataString) { showLicenseModal(); return; }
            const licenseData = JSON.parse(licenseDataString);
            const sevenDaysInMillis = 7 * 24 * 60 * 60 * 1000;
            if ((new Date().getTime() - licenseData.lastValidated) < sevenDaysInMillis) { unlockApp(); return; }
            try {
                const licenseRef = doc(db, 'activatedLicenses', licenseData.key);
                const licenseSnap = await getDoc(licenseRef);
                if (licenseSnap.exists() && licenseSnap.data().uid === auth.currentUser.uid) {
                    licenseData.lastValidated = new Date().getTime();
                    localStorage.setItem('atmaLicense', JSON.stringify(licenseData));
                    unlockApp();
                } else {
                    localStorage.removeItem('atmaLicense');
                    showLicenseModal();
                    licenseError.textContent = 'License re-validation failed. Please enter again.';
                }
            } catch (error) {
                console.error("Error re-verifying license:", error);
                unlockApp(); // Fallback
            }
        };

        // --- INITIALIZATION ---
        window.onload = () => {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    // User is signed in (persistently).
                    checkLicenseOnLoad();
                } else {
                    // No user is signed in, sign in anonymously.
                    signInAnonymously(auth).catch((error) => {
                        console.error("Anonymous auth failed:", error);
                        showLicenseModal();
                        licenseError.textContent = "Could not connect to authentication service.";
                    });
                }
            });
        };


        // --- EVENT LISTENERS ---
        verifyLicenseBtn.addEventListener('click', verifyLicense);
        licenseKeyInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') verifyLicense(); });
        closeToastBtn.addEventListener('click', () => settingsToast.classList.add('hidden'));
        window.onresize = () => { if (appWrapper.classList.contains('unlocked')) animateToSlide(currentSlideIndex); };
        
        // --- SETTINGS MODAL LOGIC ---
        function lockIdInputUI() {
            customIdInput.value = customId;
            customIdInput.readOnly = true;
            customIdInput.classList.add('bg-gray-200', 'cursor-not-allowed');
            changeIdBtn.classList.remove('hidden');
            idActionsContainer.style.display = 'flex';
            oldIdToReplace = null; 
        }

        function unlockIdInputUIForCreation() {
            customIdInput.value = '';
            customIdInput.readOnly = false;
            customIdInput.classList.remove('bg-gray-200', 'cursor-not-allowed');
            changeIdBtn.classList.add('hidden');
            idActionsContainer.style.display = 'none';
            oldIdToReplace = null;
        }

        function unlockIdInputUIForChange() {
            oldIdToReplace = customId; 
            customIdInput.readOnly = false;
            customIdInput.classList.remove('bg-gray-200', 'cursor-not-allowed');
            customIdInput.focus();
            changeIdBtn.classList.add('hidden');
            idActionsContainer.style.display = 'flex'; // Actions should still be visible
        }
        
        function updateSaveButtonState() {
            const currentLang = langIdButton.classList.contains('bg-black') ? 'id' : 'eng';
            
            let idChanged = false;
            // Only consider ID changed if the input is unlocked for creation or changing
            if (!customIdInput.readOnly) {
                idChanged = customIdInput.value !== customId;
            }

            if (currentLang !== initialSettings.lang || idChanged) {
                saveSettingsBtn.textContent = 'Save & Close';
            } else {
                saveSettingsBtn.textContent = 'Close';
            }
        }

        function resetDeleteButtonState() {
            if (deleteConfirmationTimeout) {
                clearTimeout(deleteConfirmationTimeout);
                deleteConfirmationTimeout = null;
            }
            deleteIdBtn.classList.remove('bg-red-900');
            deleteIdBtn.classList.add('bg-red-700');
            deleteIdBtn.textContent = 'Delete ID';
        }

        async function openSettingsModal() {
            // Store initial state for change detection
            initialSettings = {
                lang: currentLanguage,
                id: customId 
            };
            
            updateLanguageUI(currentLanguage);
            
            // This section is now simpler as we are always in 'printed' mode.
            if (customId) {
                lockIdInputUI();
            } else {
                unlockIdInputUIForCreation();
            }

            updateSaveButtonState(); // Set initial button text

            customIdError.textContent = '';
            resetDeleteButtonState();
            
            settingsModal.classList.remove('hidden');
        }

        function closeSettingsModal() { 
            // If trying to close without a Custom ID, show an error and prevent closing.
            if (!customId) {
                customIdError.textContent = translations[currentLanguage].mustSetId;
                return; // Stop the function here.
            }

            // If an ID exists, proceed with closing as normal.
            resetDeleteButtonState();
            oldIdToReplace = null; // Ensure state is reset on close
            settingsModal.classList.add('hidden'); 
            customIdError.textContent = ''; // Clear any previous errors
        }

        function updateLanguageUI(lang) {
             const t = translations[lang];
             settingsTitle.textContent = t.settingsTitle;
             languageLabel.textContent = t.languageLabel;
             langIdButton.textContent = t.langId;
             langEngButton.textContent = t.langEng;
             if (lang === 'id') {
                 langIdButton.className = 'font-playfair flex-1 p-2 rounded-sm border-2 uppercase tracking-wider border-black bg-black text-[#fdfaf3]';
                 langEngButton.className = 'font-playfair flex-1 p-2 rounded-sm border-2 uppercase tracking-wider border-black bg-transparent text-black';
             } else {
                 langEngButton.className = 'font-playfair flex-1 p-2 rounded-sm border-2 uppercase tracking-wider border-black bg-black text-[#fdfaf3]';
                 langIdButton.className = 'font-playfair flex-1 p-2 rounded-sm border-2 uppercase tracking-wider border-black bg-transparent text-black';
             }
             updateSaveButtonState();
        }

        async function saveSettings() {
            // 1. Handle 'Close' case (no changes)
            if (saveSettingsBtn.textContent === 'Close') {
                closeSettingsModal();
                return;
            }

            resetDeleteButtonState();
            
            // 2. Read final state from UI
            const finalLang = langIdButton.classList.contains('bg-black') ? 'id' : 'eng';
            const finalIdInput = customIdInput.value;

            // 3. Check if a reset is needed
            const needsReset = finalLang !== currentLanguage || (finalIdInput !== customId && finalIdInput);

            // 4. Handle Printed QR Mode Firestore Logic (this is the only logic now)
            const idChanged = finalIdInput !== customId;
            const isCreating = !customId && finalIdInput;
            const isReplacing = customId && idChanged;

            if (isCreating || isReplacing) {
                // Validate the new ID
                if (!/^[0-9]{6}$/.test(finalIdInput)) {
                    customIdError.textContent = 'ID must be exactly 6 digits.';
                    return;
                }

                try {
                    // Check if new ID is available
                    const newDocRef = doc(db, 'printedQR', finalIdInput);
                    const docSnap = await getDoc(newDocRef);
                    if (docSnap.exists()) {
                        customIdError.textContent = 'This ID is already taken.';
                        return;
                    }

                    // If replacing, delete the old document
                    if (isReplacing) {
                        const oldDocRef = doc(db, 'printedQR', customId);
                        await deleteDoc(oldDocRef);
                    }

                    // Create the new document
                    await setDoc(newDocRef, { id: '', lang: finalLang, updatedAt: serverTimestamp() });
                    // If successful, update the app's customId state variable
                    customId = finalIdInput;

                } catch (error) {
                    console.error("Error creating/replacing ID:", error);
                    customIdError.textContent = 'Failed to update ID. Check connection.';
                    return;
                }
            }
            // Handle case where only language changed for an existing ID
            else if (finalLang !== currentLanguage && customId) {
                 try {
                     const docRef = doc(db, 'printedQR', customId);
                     await setDoc(docRef, { lang: finalLang }, { merge: true });
                 } catch (error) {
                     console.error("Error updating language in Firestore:", error);
                 }
            }

            // 5. Commit final state
            currentLanguage = finalLang;

            localStorage.setItem('atmaSettings', JSON.stringify({ id: customId, lang: currentLanguage }));
            
            closeSettingsModal();

            if (needsReset) {
                resetApp();
            }
        }
        
        function loadSettings() {
            const savedSettings = JSON.parse(localStorage.getItem('atmaSettings')) || {};
            customId = savedSettings.id || '';
            currentLanguage = savedSettings.lang || 'eng';
            resetApp();

            // *** NEW: Automatically open settings if no Custom ID is set ***
            if (!customId) {
                openSettingsModal();
            }
        }

        function downloadQrCode() {
            if (!customId) {
                customIdError.textContent = 'Please set and save a 6-digit ID first.';
                return;
            }
            // Opens generateqr.html in a new tab with the custom ID
            window.open(`generateqr.html?id=${customId}`, '_blank');
        }
        
        async function deleteId() {
             const idToDelete = customIdInput.value;
             if (!/^[0-9]{6}$/.test(idToDelete) || idToDelete !== customId) {
                 customIdError.textContent = 'Error: ID mismatch or invalid.';
                 resetDeleteButtonState();
                 return;
             }
             
             // If confirmation not running, set for 3 seconds
             if (!deleteConfirmationTimeout) {
                 deleteIdBtn.classList.remove('bg-red-700');
                 deleteIdBtn.classList.add('bg-red-900');
                 deleteIdBtn.textContent = 'Confirm Delete?';
                 deleteConfirmationTimeout = setTimeout(resetDeleteButtonState, 3000);
                 return;
             }

             // If here, confirmation button was clicked
             clearTimeout(deleteConfirmationTimeout);
            
             try {
                 const docRef = doc(db, 'printedQR', idToDelete);
                 
                 // Directly delete without server-side ownership check
                 await deleteDoc(docRef);
                 customIdError.textContent = `ID ${idToDelete} has been deleted.`;
                 
                 // Clear from local state
                 const currentLang = currentLanguage;
                 customId = '';
                 localStorage.setItem('atmaSettings', JSON.stringify({
                     id: '',
                     lang: currentLang
                 }));

                 // Reset UI to creation state after successful deletion
                 unlockIdInputUIForCreation();
                 updateSaveButtonState();

             } catch (error) {
                 console.error('Error deleting ID:', error);
                 customIdError.textContent = 'Failed to delete ID. Check connection.';
             } finally {
                 resetDeleteButtonState();
             }
        }

        langIdButton.addEventListener('click', () => updateLanguageUI('id'));
        langEngButton.addEventListener('click', () => updateLanguageUI('eng'));
        changeIdBtn.addEventListener('click', unlockIdInputUIForChange);
        saveSettingsBtn.addEventListener('click', saveSettings);
        downloadQrBtn.addEventListener('click', downloadQrCode);
        deleteIdBtn.addEventListener('click', deleteId);
        customIdInput.addEventListener('input', updateSaveButtonState);
        settingsModal.addEventListener('click', (e) => { if (e.target === settingsModal) closeSettingsModal(); });

        // --- NEW SECURITY & HELPER FUNCTIONS ---
        async function updatePerformingStatus(isPerforming) {
            if (!customId || !auth.currentUser) return;
            try {
                const docRef = doc(db, 'printedQR', customId);
                await setDoc(docRef, { isPerforming: isPerforming, updatedAt: serverTimestamp() }, { merge: true });
                console.log(`Set isPerforming to ${isPerforming} for ID:`, customId);
            } catch (error) {
                console.error('Failed to update performing status in Firestore:', error);
            }
        }

        // --- APP CORE FUNCTIONS ---
        function createSlide(slideIndex) {
            const slide = document.createElement('div');
            slide.className = 'slide';
            const slideContent = document.createElement('div');
            slideContent.className = 'slide-content';

            if (slideIndex < 3) {
                const contentData = displayContent[currentLanguage][slideIndex];
                const listItems = contentData.items.map(item => `<li class="ml-4 text-xl">• ${item}</li>`).join('');
                slideContent.innerHTML = `
                    <div class="text-left w-full h-full flex flex-col justify-center">
                        <h2 class="text-3xl font-bold mb-4">${contentData.title}</h2>
                        <ul class="list-none space-y-2">${listItems}</ul>
                    </div>`;
            } else { // Last slide logic - always the image now
                // Remove padding for the image slide to fill the container
                slideContent.style.padding = '0';
                slideContent.innerHTML = `<img src="https://deyiksanjaya.github.io/atma/image1.jpg" alt="Initial image">`;
            }
            slide.appendChild(slideContent);
            return slide;
        }
        
        function animateToSlide(slideIndex, isInstant = false) {
            const previousSlideIndex = currentSlideIndex;
            const transitionDuration = isInstant ? 0 : 400; // in ms
            slideContainer.style.transition = isInstant ? 'none' : `transform ${transitionDuration / 1000}s ease-in-out`;
            const slideWidth = displayArea.getBoundingClientRect().width;
            const totalTranslation = (slideWidth * slideIndex) + (SLIDE_GAP * slideIndex);
            slideContainer.style.transform = `translateX(-${totalTranslation}px)`;
            currentSlideIndex = slideIndex;
            
            // Secretly change image when swiping away from it after the trick is done
            if (!isSessionActive && !isImageRevealed && previousSlideIndex === 3 && currentSlideIndex !== 3) {
                const lastSlideContent = slideContainer.children[3].querySelector('.slide-content');
                if(lastSlideContent) {
                    // Wait for the transition to finish before changing the image
                    setTimeout(function() {
                        lastSlideContent.innerHTML = `<img src="https://deyiksanjaya.github.io/atma/image2.jpg" alt="Revealed image">`;
                        isImageRevealed = true; // Mark as revealed to prevent re-changing
                    }, transitionDuration);
                }
            }
        }

        function setupInitialView() {
            slideContainer.innerHTML = '';
            for(let i = 0; i < TOTAL_SLIDES; i++) {
                slideContainer.appendChild(createSlide(i));
            }
            animateToSlide(0, true);
        }
        
        function resetApp() {
            gestureCount = 0;
            currentSlideIndex = 0;
            gestureSequence.length = 0;
            gestureTextHistory.length = 0;
            isSessionActive = true;
            tapCount = 0;
            lastTapTime = 0;
            isImageRevealed = false; // Reset the image reveal state
            
            const t = translations[currentLanguage];
            settingsTitle.textContent = t.settingsTitle;
            languageLabel.textContent = t.languageLabel;
            readInstructionsButton.textContent = t.readInstructions;

            setupInitialView();
            if (customId) {
                // Clear previous gesture data and set performing status to true for the new session
                updateGestureDataInFirestore(); 
                updatePerformingStatus(true);
            }
        }
        
        async function updateGestureDataInFirestore() {
            // Stop if no customId, or not logged in
            if (!customId || !auth.currentUser) return;
            try {
                const docRef = doc(db, 'printedQR', customId);
                const dataToSave = {
                    id: gestureSequence.join(''),
                    lang: currentLanguage,
                    updatedAt: serverTimestamp()
                };
                // Use setDoc to overwrite old data with new data
                await setDoc(docRef, dataToSave, { merge: true }); 
                console.log('Gesture data updated in Firestore for ID:', customId);
            } catch (error) {
                console.error('Failed to update gesture data in Firestore:', error);
            }
        }

        function showHistoryOverlay() {
            if (gestureTextHistory.length === 0) {
                historyOverlayElement.innerHTML = `<ul><li>${translations[currentLanguage].noHistory}</li></ul>`;
            } else {
                const historyHtml = `<ul>${gestureTextHistory.map(item => `<li class="mb-1">${item}</li>`).join('')}</ul>`;
                historyOverlayElement.innerHTML = historyHtml;
            }
            historyOverlayElement.classList.add('show');
        }

        function hideHistoryOverlay() { historyOverlayElement.classList.remove('show'); }

        function getGridArea(clientX, clientY) {
            const rect = displayArea.getBoundingClientRect();
            if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return null;
            const localX = clientX - rect.left;
            const localY = clientY - rect.top;
            const centerXStart = rect.width * 0.25, centerXEnd = rect.width * 0.75;
            const centerYStart = rect.height * 0.25, centerYEnd = rect.height * 0.75;
            if (localX > centerXStart && localX < centerXEnd && localY > centerYStart && localY < centerYEnd) return 'e';
            const midX = rect.width / 2, midY = rect.height / 2;
            if (localX < midX && localY < midY) return 'a';
            if (localX >= midX && localY < midY) return 'b';
            if (localX < midX && localY >= midY) return 'c';
            if (localX >= midX && localY >= midY) return 'd';
            return null;
        }

        touchArea.addEventListener('touchstart', (e) => {
            if (!appWrapper.classList.contains('unlocked') || e.target.closest('#settings-modal')) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;

            if (isSessionActive) {
                startArea = getGridArea(startX, startY);
            } else {
                isDragging = false;
                slideContainer.style.transition = 'none';
                const slideWidth = displayArea.getBoundingClientRect().width;
                initialTranslate = -((slideWidth * currentSlideIndex) + (SLIDE_GAP * currentSlideIndex));
                tapHoldTimeout = setTimeout(showHistoryOverlay, TAP_HOLD_DURATION);
            }
        }, { passive: false });

        touchArea.addEventListener('touchmove', (e) => {
            if (!appWrapper.classList.contains('unlocked') || e.target.closest('#settings-modal')) return;
            e.preventDefault();
            
            if (!isSessionActive) {
                const currentX = e.touches[0].clientX;
                const diffX = currentX - startX;
                if (Math.abs(diffX) > TAP_THRESHOLD) {
                    isDragging = true;
                    if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
                }
                if (isDragging) {
                    slideContainer.style.transform = `translateX(${initialTranslate + diffX}px)`;
                }
            }
        }, { passive: false });

        touchArea.addEventListener('touchend', (e) => {
            if (!appWrapper.classList.contains('unlocked') || e.target.closest('#settings-modal')) return;

            if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
            hideHistoryOverlay();

            const endX = e.changedTouches[0].clientX;
            const endY = e.changedTouches[0].clientY;
            const diffX = endX - startX;
            const absDiffX = Math.abs(diffX);
            const absDiffY = Math.abs(endY - startY);
            const isTap = absDiffX < TAP_THRESHOLD && absDiffY < TAP_THRESHOLD;

            // Settings corner tap
            if (isTap && endX > window.innerWidth - SETTINGS_CORNER_SIZE && endY < SETTINGS_CORNER_SIZE) {
                openSettingsModal();
                return;
            }

            if (!isSessionActive) {
                if (isTap) {
                    const currentTime = new Date().getTime();
                    tapCount = (currentTime - lastTapTime < DOUBLE_TAP_TIMEOUT) ? tapCount + 1 : 1;
                    lastTapTime = currentTime;
                    
                    if (tapCount === 2) {
                        // Set isPerforming to false
                        if (customId) {
                            updatePerformingStatus(false);
                        }
                    } else if (tapCount === 3) {
                        resetApp();
                    }
                } else if (absDiffX > SWIPE_THRESHOLD) {
                    let newSlideIndex = currentSlideIndex;
                    if (diffX < 0 && currentSlideIndex < TOTAL_SLIDES - 1) newSlideIndex++;
                    else if (diffX > 0 && currentSlideIndex > 0) newSlideIndex--;
                    animateToSlide(newSlideIndex); // Pass the new index to the animation function
                } else {
                    animateToSlide(currentSlideIndex); // Snap back if not a full swipe
                }
                isDragging = false;
                return;
            }

            // Block gestures if no valid ID
            if (!customId) {
                const originalText = settingsToast.querySelector('p').textContent;
                settingsToast.querySelector('p').textContent = 'Please set a Custom ID in settings first.';
                settingsToast.classList.remove('hidden');
                setTimeout(() => {
                    settingsToast.classList.add('hidden');
                    settingsToast.querySelector('p').textContent = originalText;
                }, 3000);
                return;
            }

            let detectedGesture = '';
            if (!isTap && startArea && diffX < -SWIPE_THRESHOLD && absDiffX > absDiffY) {
                detectedGesture = gridToGesture[startArea];
            }
            
            startArea = null;
            if (!detectedGesture) return;

            const gestureCode = gestureToCode[detectedGesture];
            if (gestureCode) {
                gestureSequence.push(gestureCode);
                const textKey = gestureToTextKey[detectedGesture];
                const textToShow = gestureTexts[gestureCount][textKey];
                if (textToShow) gestureTextHistory.push(textToShow);
                gestureCount++;
                                                
                animateToSlide(gestureCount);

                if (gestureCount >= 3) {
                    isSessionActive = false;
                    
                    updateGestureDataInFirestore();
                    // The image reveal logic is handled by animateToSlide
                }
            }
        });

    </script>
        <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered successfully with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('Service Worker registration failed: ', error);
                    });
            });
        }
        </script>
</body>
</html>
